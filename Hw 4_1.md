![[1.png]](1.png)

As we can see on the first image, explicit constructor performs, when direct-initialization syntax or casts are used, so not a copy initialization (x)


![[2.png]](2.png)

![[3.png]](3.png)

According to the 2nd and 3rd images, our code:
```
template <class T1, class T2> struct Pair {
	template<class U1 = T1, class U2 = T2> Pair(U1&&, U2&&) {}
};

struct S { S() = default; };

struct E { explicit E() = default; };

int f(Pair<E, E>) { return 1; }

int f(Pair<S, S>) { return 2; }

int main() {
	assert(f({{}}, {{}}) == 2); // OK
}
```

This initialization of f will perform as copy-list initialization that will be marked not viable for struct E, according to the (x), so there won't be any conflict with choosing a user-defined conversion sequence further, so only S will be suitable for this initialization. 
### Answer
Should be OK, because S will be chosen by compiler without any doubts, struct E not viable
